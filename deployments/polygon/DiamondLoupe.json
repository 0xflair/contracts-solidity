{
  "address": "0x39e8Ba263E6fAF61A8D5b8F99755bA0F582e0b86",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "facetAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "facetAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facetAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "facetAddresses_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_facet",
          "type": "address"
        }
      ],
      "name": "facetFunctionSelectors",
      "outputs": [
        {
          "internalType": "bytes4[]",
          "name": "facetFunctionSelectors_",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facets",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondLoupe.Facet[]",
          "name": "facets_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe0c892e895750dbe971f3d2181d746c52110e7c06c6b1e26403ea0bd73afc92d",
  "receipt": {
    "to": null,
    "from": "0xB68d649F181bDE8A8FeE367535a606Cc3C09fCCd",
    "contractAddress": "0x39e8Ba263E6fAF61A8D5b8F99755bA0F582e0b86",
    "transactionIndex": 0,
    "gasUsed": "426438",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000008000000000000000000000000000000000000000000000000000000000800000000000000400000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000080000000000000000100000000000000000000000000000001000000000000000000000000004000000000000100020",
    "blockHash": "0xc25fff2b19365667d352ea7cb639b5f4e8ff7901b3a260897da4b41334d08e98",
    "transactionHash": "0xe0c892e895750dbe971f3d2181d746c52110e7c06c6b1e26403ea0bd73afc92d",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 33809261,
        "transactionHash": "0xe0c892e895750dbe971f3d2181d746c52110e7c06c6b1e26403ea0bd73afc92d",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000b68d649f181bde8a8fee367535a606cc3c09fccd",
          "0x000000000000000000000000127685d6dd6683085da4b6a041efcef1681e5c9c"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000097804f66915ab8000000000000000000000000000000000000000000000001dacbf3c4eb62a0940000000000000000000000000000000000000000000001b79caf0e5011e22d63000000000000000000000000000000000000000000000001da34737584d145dc0000000000000000000000000000000000000000000001b79d468e9f7873881b",
        "logIndex": 0,
        "blockHash": "0xc25fff2b19365667d352ea7cb639b5f4e8ff7901b3a260897da4b41334d08e98"
      }
    ],
    "blockNumber": 33809261,
    "cumulativeGasUsed": "426438",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a9fa8c998440b5be2b92171b1128d13c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"facetFunctionSelectors_\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"custom:category\":\"Diamonds\",\"custom:provides-interfaces\":\"0x48e2b093\",\"custom:type\":\"eip-2535-facet\",\"kind\":\"dev\",\"methods\":{\"facetAddress(bytes4)\":{\"details\":\"If facet is not found return address(0).\",\"params\":{\"_functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"facetAddresses_\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"_facet\":\"The facet address.\"},\"returns\":{\"facetFunctionSelectors_\":\"facetFunctionSelectors_\"}},\"facets()\":{\"returns\":{\"facets_\":\"Facet\"}}},\"title\":\"Diamond - Loupe\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet that supports the given selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by a diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors provided by a facet.\"},\"facets()\":{\"notice\":\"Gets all facets and their selectors.\"}},\"notice\":\"Standard EIP-2535 loupe functions to allow inspecting a diamond for explorers.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/diamond/DiamondLoupe.sol\":\"DiamondLoupe\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1337},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"src/diamond/DiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport \\\"./DiamondStorage.sol\\\";\\nimport \\\"./IDiamondLoupe.sol\\\";\\n\\n// The functions in DiamondLoupe MUST be added to a diamond.\\n// The EIP-2535 Diamond standard requires these functions.\\n\\n/**\\n * @title Diamond - Loupe\\n * @notice Standard EIP-2535 loupe functions to allow inspecting a diamond for explorers.\\n *\\n * @custom:type eip-2535-facet\\n * @custom:category Diamonds\\n * @custom:provides-interfaces 0x48e2b093\\n */\\ncontract DiamondLoupe is IDiamondLoupe {\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external view override returns (Facet[] memory facets_) {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        uint256 numFacets = l.facetAddresses.length;\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; i++) {\\n            address facetAddress_ = l.facetAddresses[i];\\n            facets_[i].facetAddress = facetAddress_;\\n            facets_[i].functionSelectors = l.facetFunctionSelectors[facetAddress_].functionSelectors;\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors provided by a facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        override\\n        returns (bytes4[] memory facetFunctionSelectors_)\\n    {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        facetFunctionSelectors_ = l.facetFunctionSelectors[_facet].functionSelectors;\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        facetAddresses_ = l.facetAddresses;\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        facetAddress_ = l.selectorToFacetAndPosition[_functionSelector].facetAddress;\\n    }\\n}\\n\",\"keccak256\":\"0x1b5003e7d2e62f8243717f08ef53ec6278f0237a217b6e550a30709c9fdebe4c\",\"license\":\"MIT\"},\"src/diamond/DiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../diamond/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror DiamondFacetAlreadyExists(address facet, bytes4 selector);\\nerror DiamondFacetSameFunction(address facet, bytes4 selector);\\n\\nlibrary DiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct Layout {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            l.slot := position\\n        }\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        // require(\\n        //     _functionSelectors.length > 0,\\n        //     \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        // );\\n        Layout storage l = layout();\\n        // require(\\n        //     _facetAddress != address(0),\\n        //     \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        // );\\n        uint96 selectorPosition = uint96(l.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(l, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = l.selectorToFacetAndPosition[selector].facetAddress;\\n\\n            if (oldFacetAddress != address(0)) {\\n                revert DiamondFacetAlreadyExists(oldFacetAddress, selector);\\n            }\\n\\n            addFunction(l, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        // require(\\n        //     _functionSelectors.length > 0,\\n        //     \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        // );\\n        Layout storage l = layout();\\n        // require(\\n        //     _facetAddress != address(0),\\n        //     \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        // );\\n        uint96 selectorPosition = uint96(l.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(l, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = l.selectorToFacetAndPosition[selector].facetAddress;\\n\\n            if (oldFacetAddress == _facetAddress) {\\n                revert DiamondFacetSameFunction(oldFacetAddress, selector);\\n            }\\n\\n            removeFunction(l, oldFacetAddress, selector);\\n            addFunction(l, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        // require(\\n        //     _functionSelectors.length > 0,\\n        //     \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        // );\\n        Layout storage l = layout();\\n        // if function does not exist then do nothing and return\\n        // require(\\n        //     _facetAddress == address(0),\\n        //     \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        // );\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = l.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(l, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(Layout storage l, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        l.facetFunctionSelectors[_facetAddress].facetAddressPosition = l.facetAddresses.length;\\n        l.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        Layout storage l,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        l.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        l.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        l.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        Layout storage l,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        // require(\\n        //     _facetAddress != address(0),\\n        //     \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        // );\\n        // an immutable function is a function defined directly in a diamond\\n        // require(\\n        //     _facetAddress != address(this),\\n        //     \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        // );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = l.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = l.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = l.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            l.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            l.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        l.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete l.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = l.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = l.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = l.facetAddresses[lastFacetAddressPosition];\\n                l.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                l.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            l.facetAddresses.pop();\\n            delete l.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xb7a92fff6899f7e99d67cf8bde29a454440ebfb677ccb6b3b262e2e4682658ae\",\"license\":\"MIT\"},\"src/diamond/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xb85e6227a1c576c2ecca3d896f95b298ec7a918b74700d6e4999a1cd8fc89b95\",\"license\":\"MIT\"},\"src/diamond/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x58bc79a9f2484a2216b1d08185344725f0c6fbf627861fd043b36eb9c7b795b3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506106c5806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc6146100a4575b600080fd5b610059610126565b6040516100669190610490565b60405180910390f35b6100776101ab565b604051610066919061053a565b6100976100923660046105b7565b61039d565b60405161006691906105e7565b61010e6100b23660046105fa565b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c60205260409020546001600160a01b031690565b6040516001600160a01b039091168152602001610066565b606060007fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c600281018054604080516020808402820181019092528281529394508301828280156101a057602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610182575b505050505091505090565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131e546060907fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c908067ffffffffffffffff81111561020b5761020b61063c565b60405190808252806020026020018201604052801561025157816020015b6040805180820190915260008152606060208201528152602001906001900390816102295790505b50925060005b8181101561039757600083600201828154811061027657610276610652565b9060005260206000200160009054906101000a90046001600160a01b03169050808583815181106102a9576102a9610652565b6020908102919091018101516001600160a01b03928316905290821660009081526001860182526040908190208054825181850281018501909352808352919290919083018282801561035d57602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161030a5790505b505050505085838151811061037457610374610652565b60200260200101516020018190525050808061038f90610668565b915050610257565b50505090565b6001600160a01b03811660009081527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d602090815260409182902080548351818402810184019094528084526060937fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c939092919083018282801561048357602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190600401906020826003010492830192600103820291508084116104305790505b5050505050915050919050565b6020808252825182820181905260009190848201906040850190845b818110156104d15783516001600160a01b0316835292840192918401916001016104ac565b50909695505050505050565b600081518084526020808501945080840160005b8381101561052f5781517fffffffff0000000000000000000000000000000000000000000000000000000016875295820195908201906001016104f1565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b838110156105a957888303603f19018552815180516001600160a01b03168452870151878401879052610596878501826104dd565b9588019593505090860190600101610561565b509098975050505050505050565b6000602082840312156105c957600080fd5b81356001600160a01b03811681146105e057600080fd5b9392505050565b6020815260006105e060208301846104dd565b60006020828403121561060c57600080fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146105e057600080fd5b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60006001820161068857634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220956854b6a36937cc51d45b68549ced6d1e10b5ecc557b2b25cd11eda0e834a6464736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc6146100a4575b600080fd5b610059610126565b6040516100669190610490565b60405180910390f35b6100776101ab565b604051610066919061053a565b6100976100923660046105b7565b61039d565b60405161006691906105e7565b61010e6100b23660046105fa565b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c60205260409020546001600160a01b031690565b6040516001600160a01b039091168152602001610066565b606060007fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c600281018054604080516020808402820181019092528281529394508301828280156101a057602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610182575b505050505091505090565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131e546060907fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c908067ffffffffffffffff81111561020b5761020b61063c565b60405190808252806020026020018201604052801561025157816020015b6040805180820190915260008152606060208201528152602001906001900390816102295790505b50925060005b8181101561039757600083600201828154811061027657610276610652565b9060005260206000200160009054906101000a90046001600160a01b03169050808583815181106102a9576102a9610652565b6020908102919091018101516001600160a01b03928316905290821660009081526001860182526040908190208054825181850281018501909352808352919290919083018282801561035d57602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161030a5790505b505050505085838151811061037457610374610652565b60200260200101516020018190525050808061038f90610668565b915050610257565b50505090565b6001600160a01b03811660009081527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d602090815260409182902080548351818402810184019094528084526060937fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c939092919083018282801561048357602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190600401906020826003010492830192600103820291508084116104305790505b5050505050915050919050565b6020808252825182820181905260009190848201906040850190845b818110156104d15783516001600160a01b0316835292840192918401916001016104ac565b50909695505050505050565b600081518084526020808501945080840160005b8381101561052f5781517fffffffff0000000000000000000000000000000000000000000000000000000016875295820195908201906001016104f1565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b838110156105a957888303603f19018552815180516001600160a01b03168452870151878401879052610596878501826104dd565b9588019593505090860190600101610561565b509098975050505050505050565b6000602082840312156105c957600080fd5b81356001600160a01b03811681146105e057600080fd5b9392505050565b6020815260006105e060208301846104dd565b60006020828403121561060c57600080fd5b81357fffffffff00000000000000000000000000000000000000000000000000000000811681146105e057600080fd5b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60006001820161068857634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220956854b6a36937cc51d45b68549ced6d1e10b5ecc557b2b25cd11eda0e834a6464736f6c634300080f0033",
  "devdoc": {
    "custom:category": "Diamonds",
    "custom:provides-interfaces": "0x48e2b093",
    "custom:type": "eip-2535-facet",
    "kind": "dev",
    "methods": {
      "facetAddress(bytes4)": {
        "details": "If facet is not found return address(0).",
        "params": {
          "_functionSelector": "The function selector."
        },
        "returns": {
          "facetAddress_": "The facet address."
        }
      },
      "facetAddresses()": {
        "returns": {
          "facetAddresses_": "facetAddresses_"
        }
      },
      "facetFunctionSelectors(address)": {
        "params": {
          "_facet": "The facet address."
        },
        "returns": {
          "facetFunctionSelectors_": "facetFunctionSelectors_"
        }
      },
      "facets()": {
        "returns": {
          "facets_": "Facet"
        }
      }
    },
    "title": "Diamond - Loupe",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "facetAddress(bytes4)": {
        "notice": "Gets the facet that supports the given selector."
      },
      "facetAddresses()": {
        "notice": "Get all the facet addresses used by a diamond."
      },
      "facetFunctionSelectors(address)": {
        "notice": "Gets all the function selectors provided by a facet."
      },
      "facets()": {
        "notice": "Gets all facets and their selectors."
      }
    },
    "notice": "Standard EIP-2535 loupe functions to allow inspecting a diamond for explorers.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}