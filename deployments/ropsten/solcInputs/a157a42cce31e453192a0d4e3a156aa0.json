{
  "language": "Solidity",
  "sources": {
    "src/token/ERC1155/facets/metadata/ERC1155MetadataOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../../../../access/ownable/OwnableInternal.sol\";\n\nimport \"./ERC1155MetadataInternal.sol\";\nimport \"./ERC1155MetadataStorage.sol\";\nimport \"./IERC1155MetadataAdmin.sol\";\n\n/**\n * @title ERC1155 - Metadata - Admin - Ownable\n * @notice Allows diamond owner to change base, per-token, and fallback URIs, as wel as freezing URIs.\n * @dev See https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions\n *\n * @custom:type eip-2535-facet\n * @custom:category NFTs\n * @custom:peer-dependencies eip165:0x0e89341c\n * @custom:provides-interfaces 0x0dfe03d4\n */\ncontract ERC1155MetadataOwnable is IERC1155MetadataAdmin, ERC1155MetadataInternal, OwnableInternal {\n    function setBaseURI(string calldata newBaseURI) public onlyOwner {\n        _setBaseURI(newBaseURI);\n    }\n\n    function setFallbackURI(string calldata newFallbackURI) public onlyOwner {\n        _setFallbackURI(newFallbackURI);\n    }\n\n    function setURISuffix(string calldata newURISuffix) public onlyOwner {\n        _setURISuffix(newURISuffix);\n    }\n\n    function setURI(uint256 tokenId, string calldata newTokenURI) public onlyOwner {\n        _setURI(tokenId, newTokenURI);\n    }\n\n    function setURIBatch(uint256[] calldata tokenIds, string[] calldata newTokenURIs) public onlyOwner {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _setURI(tokenIds[i], newTokenURIs[i]);\n        }\n    }\n\n    function lockBaseURI() public onlyOwner {\n        _lockBaseURI();\n    }\n\n    function lockFallbackURI() public onlyOwner {\n        _lockFallbackURI();\n    }\n\n    function lockURISuffix() public onlyOwner {\n        _lockURISuffix();\n    }\n\n    function lockURIUntil(uint256 tokenId) public onlyOwner {\n        _lockURIUntil(tokenId);\n    }\n}\n"
    },
    "src/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./OwnableStorage.sol\";\nimport \"./IERC173Events.sol\";\n\nabstract contract OwnableInternal is IERC173Events, Context {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(_msgSender() == _owner(), \"Ownable: sender must be owner\");\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(_msgSender(), account);\n    }\n}\n"
    },
    "src/token/ERC1155/facets/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"./IERC1155MetadataEvents.sol\";\nimport \"./ERC1155MetadataStorage.sol\";\n\nabstract contract ERC1155MetadataInternal is IERC1155MetadataEvents {\n    function _setBaseURI(string memory baseURI) internal {\n        require(!ERC1155MetadataStorage.layout().baseURILocked, \"ERC1155Metadata: baseURI locked\");\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    function _setFallbackURI(string memory baseURI) internal {\n        require(!ERC1155MetadataStorage.layout().fallbackURILocked, \"ERC1155Metadata: fallbackURI locked\");\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    function _setURI(uint256 tokenId, string memory tokenURI) internal {\n        require(tokenId > ERC1155MetadataStorage.layout().lastLockedTokenId, \"ERC1155Metadata: tokenURI locked\");\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n\n    function _setURISuffix(string memory uriSuffix) internal {\n        require(!ERC1155MetadataStorage.layout().uriSuffixLocked, \"ERC1155Metadata: uriSuffix locked\");\n        ERC1155MetadataStorage.layout().uriSuffix = uriSuffix;\n    }\n\n    function _lockBaseURI() internal {\n        ERC1155MetadataStorage.layout().baseURILocked = true;\n    }\n\n    function _lockFallbackURI() internal {\n        ERC1155MetadataStorage.layout().fallbackURILocked = true;\n    }\n\n    function _lockURIUntil(uint256 tokenId) internal {\n        ERC1155MetadataStorage.layout().lastLockedTokenId = tokenId;\n    }\n\n    function _lockURISuffix() internal {\n        ERC1155MetadataStorage.layout().uriSuffixLocked = true;\n    }\n}\n"
    },
    "src/token/ERC1155/facets/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"v2.flair.contracts.storage.ERC1155Metadata\");\n\n    struct Layout {\n        string baseURI;\n        bool baseURILocked;\n        string fallbackURI;\n        bool fallbackURILocked;\n        string uriSuffix;\n        bool uriSuffixLocked;\n        uint256 lastLockedTokenId;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "src/token/ERC1155/facets/metadata/IERC1155MetadataAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IERC1155MetadataAdmin {\n    function setBaseURI(string calldata newBaseURI) external;\n\n    function setFallbackURI(string calldata newFallbackURI) external;\n\n    function setURI(uint256 tokenId, string calldata newTokenURI) external;\n\n    function setURIBatch(uint256[] calldata tokenIds, string[] calldata newTokenURIs) external;\n\n    function lockBaseURI() external;\n\n    function lockFallbackURI() external;\n\n    function lockURIUntil(uint256 tokenId) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"openzeppelin.contracts.storage.Ownable\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "src/access/ownable/IERC173Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\n/**\n * @title Contract ownership standard interface (event only)\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173Events {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/token/ERC1155/facets/metadata/IERC1155MetadataEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IERC1155MetadataEvents {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "src/token/ERC1155/facets/metadata/ERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./IERC1155Metadata.sol\";\nimport \"./IERC1155MetadataExtra.sol\";\nimport \"./ERC1155MetadataInternal.sol\";\nimport \"./ERC1155MetadataStorage.sol\";\n\n/**\n * @title ERC1155 - Metadata\n * @notice Provides metadata for ERC1155 tokens according to standard. This extension supports base URI, per-token URI, and a fallback URI. You can also freeze URIs until a certain token ID.\n * @dev See https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions\n *\n * @custom:type eip-2535-facet\n * @custom:category NFTs\n * @custom:peer-dependencies eip165:0xd9b67a26\n * @custom:provides-interfaces 0x0e89341c 0xc6575680\n */\ncontract ERC1155Metadata is IERC1155Metadata, IERC1155MetadataExtra, ERC1155MetadataInternal {\n    /**\n     * @notice inheritdoc IERC1155Metadata\n     */\n    function uri(uint256 tokenId) public view virtual returns (string memory) {\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage.layout();\n\n        string memory _tokenIdURI = l.tokenURIs[tokenId];\n        string memory _baseURI = l.baseURI;\n\n        if (bytes(_baseURI).length == 0) {\n            return _tokenIdURI;\n        } else if (bytes(_tokenIdURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenIdURI));\n        } else {\n            return string(abi.encodePacked(_baseURI, l.fallbackURI, Strings.toString(tokenId)));\n        }\n    }\n\n    function uriBatch(uint256[] calldata tokenIds) external view returns (string[] memory) {\n        string[] memory uris = new string[](tokenIds.length);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uris[i] = uri(tokenIds[i]);\n        }\n\n        return uris;\n    }\n\n    function baseURI() external view returns (string memory) {\n        return ERC1155MetadataStorage.layout().baseURI;\n    }\n\n    function fallbackURI() external view returns (string memory) {\n        return ERC1155MetadataStorage.layout().fallbackURI;\n    }\n\n    function uriSuffix() external view returns (string memory) {\n        return ERC1155MetadataStorage.layout().uriSuffix;\n    }\n\n    function baseURILocked() external view returns (bool) {\n        return ERC1155MetadataStorage.layout().baseURILocked;\n    }\n\n    function fallbackURILocked() external view returns (bool) {\n        return ERC1155MetadataStorage.layout().fallbackURILocked;\n    }\n\n    function uriSuffixLocked() external view returns (bool) {\n        return ERC1155MetadataStorage.layout().uriSuffixLocked;\n    }\n\n    function lastLockedTokenId() external view returns (uint256) {\n        return ERC1155MetadataStorage.layout().lastLockedTokenId;\n    }\n}\n"
    },
    "src/token/ERC1155/facets/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IERC1155Metadata {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "src/token/ERC1155/facets/metadata/IERC1155MetadataExtra.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IERC1155MetadataExtra {\n    function baseURI() external view returns (string memory);\n\n    function fallbackURI() external view returns (string memory);\n\n    function uriSuffix() external view returns (string memory);\n\n    function baseURILocked() external view returns (bool);\n\n    function fallbackURILocked() external view returns (bool);\n\n    function uriSuffixLocked() external view returns (bool);\n\n    function lastLockedTokenId() external view returns (uint256);\n\n    function uriBatch(uint256[] calldata tokenIds) external view returns (string[] memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1337
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}