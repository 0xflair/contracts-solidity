{
  "language": "Solidity",
  "sources": {
    "src/diamond/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"../access/ownable/OwnableStorage.sol\";\nimport \"../access/ownable/IERC173.sol\";\nimport \"../introspection/ERC165.sol\";\nimport \"../metatx/ERC2771Context.sol\";\nimport \"../diamond/IDiamondCut.sol\";\nimport \"../diamond/IDiamondLoupe.sol\";\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport \"./DiamondStorage.sol\";\n\ncontract Diamond is Multicall {\n    using ERC165Storage for ERC165Storage.Layout;\n    using OwnableStorage for OwnableStorage.Layout;\n\n    struct Initialization {\n        address initContract;\n        bytes initData;\n    }\n\n    struct CoreFacets {\n        address diamondCutFacet;\n        address diamondLoupeFacet;\n        address erc165Facet;\n        address erc173Facet;\n    }\n\n    constructor(\n        address owner,\n        CoreFacets memory _coreFacets,\n        IDiamondCut.FacetCut[] memory _facets,\n        Initialization[] memory _initializations\n    ) {\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\n\n        // register DiamondCut\n\n        bytes4[] memory selectorsDiamondCut = new bytes4[](1);\n        selectorsDiamondCut[0] = IDiamondCut.diamondCut.selector;\n\n        erc165.setSupportedInterface(type(IDiamondCut).interfaceId, true);\n\n        // register DiamondLoupe\n\n        bytes4[] memory selectorsDiamondLoupe = new bytes4[](4);\n        selectorsDiamondLoupe[0] = IDiamondLoupe.facets.selector;\n        selectorsDiamondLoupe[1] = IDiamondLoupe.facetFunctionSelectors.selector;\n        selectorsDiamondLoupe[2] = IDiamondLoupe.facetAddresses.selector;\n        selectorsDiamondLoupe[3] = IDiamondLoupe.facetAddress.selector;\n\n        erc165.setSupportedInterface(type(IDiamondLoupe).interfaceId, true);\n\n        // register ERC165 (supportsInterface)\n\n        bytes4[] memory selectorsERC165 = new bytes4[](1);\n        selectorsERC165[0] = IERC165.supportsInterface.selector;\n\n        erc165.setSupportedInterface(type(IERC165).interfaceId, true);\n\n        // register ERC173 (Ownable)\n\n        bytes4[] memory selectorsERC173 = new bytes4[](2);\n        selectorsERC173[0] = IERC173.owner.selector;\n        selectorsERC173[1] = IERC173.transferOwnership.selector;\n\n        erc165.setSupportedInterface(type(IERC173).interfaceId, true);\n\n        // execute the first ever diamond cut,\n        // we are calling the addFunctions directly to save ~ %50 gas\n\n        DiamondStorage.addFunctions(_coreFacets.diamondCutFacet, selectorsDiamondCut);\n        DiamondStorage.addFunctions(_coreFacets.diamondLoupeFacet, selectorsDiamondLoupe);\n        DiamondStorage.addFunctions(_coreFacets.erc165Facet, selectorsERC165);\n        DiamondStorage.addFunctions(_coreFacets.erc173Facet, selectorsERC173);\n\n        // set owner\n\n        OwnableStorage.layout().setOwner(owner);\n\n        // initialization\n\n        for (uint256 i = 0; i < _facets.length; i++) {\n            DiamondStorage.addFunctions(_facets[i].facetAddress, _facets[i].functionSelectors);\n        }\n\n        for (uint256 i = 0; i < _initializations.length; i++) {\n            DiamondStorage.initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n        }\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        DiamondStorage.Layout storage l;\n        bytes32 position = DiamondStorage.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            l.slot := position\n        }\n\n        // get facet from function selector\n        address facet = l.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"BAD_FUNC\");\n\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"openzeppelin.contracts.storage.Ownable\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "src/access/ownable/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./IERC173Events.sol\";\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Events {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conrtact owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "src/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"./ERC165Storage.sol\";\n\n/**\n * @title ERC165\n * @notice Standard EIP-165 facet which would be already included as a core facet in Flair's Diamond contract.\n *\n * @custom:type eip-2535-facet\n * @custom:category Introspection\n * @custom:provides-interfaces IERC165\n */\ncontract ERC165 is IERC165 {\n    using ERC165Storage for ERC165Storage.Layout;\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\n    }\n}\n"
    },
    "src/metatx/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./ERC2771ContextStorage.sol\";\nimport \"./ERC2771ContextInternal.sol\";\nimport \"./IERC2771Context.sol\";\n\n/**\n * @title ERC2771 Context\n * @notice Provides view functions about configured trusted forwarder according to EIP-2771.\n *\n * @custom:type eip-2535-facet\n * @custom:category Meta Transactions\n * @custom:provides-interfaces IERC2771Context\n */\ncontract ERC2771Context is IERC2771Context, ERC2771ContextInternal {\n    using ERC2771ContextStorage for ERC2771ContextStorage.Layout;\n\n    function trustedForwarder() external view override returns (address) {\n        return ERC2771ContextStorage.layout().trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return _isTrustedForwarder(forwarder);\n    }\n}\n"
    },
    "src/diamond/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/diamond/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/diamond/DiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../diamond/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror ErrDiamondFacetAlreadyExists(address facet, bytes4 selector);\nerror ErrDiamondFacetSameFunction(address facet, bytes4 selector);\n\nlibrary DiamondStorage {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct Layout {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            l.slot := position\n        }\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        // require(\n        //     _functionSelectors.length > 0,\n        //     \"LibDiamondCut: No selectors in facet to cut\"\n        // );\n        Layout storage l = layout();\n        // require(\n        //     _facetAddress != address(0),\n        //     \"LibDiamondCut: Add facet can't be address(0)\"\n        // );\n        uint96 selectorPosition = uint96(l.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(l, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = l.selectorToFacetAndPosition[selector].facetAddress;\n\n            if (oldFacetAddress != address(0)) {\n                revert ErrDiamondFacetAlreadyExists(oldFacetAddress, selector);\n            }\n\n            addFunction(l, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        // require(\n        //     _functionSelectors.length > 0,\n        //     \"LibDiamondCut: No selectors in facet to cut\"\n        // );\n        Layout storage l = layout();\n        // require(\n        //     _facetAddress != address(0),\n        //     \"LibDiamondCut: Add facet can't be address(0)\"\n        // );\n        uint96 selectorPosition = uint96(l.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(l, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = l.selectorToFacetAndPosition[selector].facetAddress;\n\n            if (oldFacetAddress == _facetAddress) {\n                revert ErrDiamondFacetSameFunction(oldFacetAddress, selector);\n            }\n\n            removeFunction(l, oldFacetAddress, selector);\n            addFunction(l, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address, bytes4[] memory _functionSelectors) internal {\n        // require(\n        //     _functionSelectors.length > 0,\n        //     \"LibDiamondCut: No selectors in facet to cut\"\n        // );\n        Layout storage l = layout();\n        // if function does not exist then do nothing and return\n        // require(\n        //     _facetAddress == address(0),\n        //     \"LibDiamondCut: Remove facet address must be address(0)\"\n        // );\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = l.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(l, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(Layout storage l, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        l.facetFunctionSelectors[_facetAddress].facetAddressPosition = l.facetAddresses.length;\n        l.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        Layout storage l,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        l.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        l.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        l.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        Layout storage l,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        // require(\n        //     _facetAddress != address(0),\n        //     \"LibDiamondCut: Can't remove function that doesn't exist\"\n        // );\n        // an immutable function is a function defined directly in a diamond\n        // require(\n        //     _facetAddress != address(this),\n        //     \"LibDiamondCut: Can't remove immutable function\"\n        // );\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = l.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = l.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = l.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            l.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            l.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        l.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete l.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = l.facetAddresses.length - 1;\n            uint256 facetAddressPosition = l.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = l.facetAddresses[lastFacetAddressPosition];\n                l.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                l.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            l.facetAddresses.pop();\n            delete l.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "src/access/ownable/IERC173Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * @title Contract ownership standard interface (event only)\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173Events {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n}\n"
    },
    "src/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary ERC165Storage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"openzeppelin.contracts.storage.ERC165\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId) internal view returns (bool) {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/metatx/ERC2771ContextStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary ERC2771ContextStorage {\n    struct Layout {\n        address trustedForwarder;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"openzeppelin.contracts.storage.ERC2771Context\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "src/metatx/ERC2771ContextInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./ERC2771ContextStorage.sol\";\n\nabstract contract ERC2771ContextInternal is Context {\n    function _isTrustedForwarder(address operator) internal view returns (bool) {\n        return ERC2771ContextStorage.layout().trustedForwarder == operator;\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (_isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (_isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
    },
    "src/metatx/IERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IERC2771Context {\n    function trustedForwarder() external view returns (address);\n\n    function isTrustedForwarder(address forwarder) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"./base/ERC20Base.sol\";\n\nimport \"./extensions/supply/ERC20SupplyExtension.sol\";\nimport \"./extensions/mintable/ERC20MintableExtension.sol\";\n\n/**\n * @title ERC20 - Standard\n * @notice Standard EIP-20 token with mintable and max supply capability.\n *\n * @custom:type eip-2535-facet\n * @custom:category Tokens\n * @custom:provides-interfaces IERC20 IERC20Base IERC20SupplyExtension IERC20MintableExtension\n */\ncontract ERC20 is ERC20Base, ERC20SupplyExtension, ERC20MintableExtension {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20BaseInternal, ERC20SupplyExtension) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "src/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport { IERC20Base } from \"./IERC20Base.sol\";\nimport { ERC20BaseInternal } from \"./ERC20BaseInternal.sol\";\nimport { ERC20BaseStorage } from \"./ERC20BaseStorage.sol\";\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20Base, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20Base\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20Base\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20Base\n     */\n    function allowance(address holder, address spender) public view virtual returns (uint256) {\n        return _allowance(holder, spender);\n    }\n\n    /**\n     * @inheritdoc IERC20Base\n     */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        return _approve(_msgSender(), spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Base\n     */\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\n        return _transfer(_msgSender(), recipient, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Base\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        return _transferFrom(holder, recipient, amount);\n    }\n}\n"
    },
    "src/token/ERC20/extensions/supply/ERC20SupplyExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport \"../../base/ERC20BaseInternal.sol\";\nimport \"./ERC20SupplyStorage.sol\";\nimport \"./ERC20SupplyInternal.sol\";\nimport \"./IERC20SupplyExtension.sol\";\n\nabstract contract ERC20SupplyExtension is IERC20SupplyExtension, ERC20BaseInternal, ERC20SupplyInternal {\n    using ERC20SupplyStorage for ERC20SupplyStorage.Layout;\n\n    function maxSupply() external view virtual override returns (uint256) {\n        return _maxSupply();\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (from == address(0)) {\n            if (to != address(0)) {\n                if (_totalSupply() + amount > ERC20SupplyStorage.layout().maxSupply) {\n                    revert ErrMaxSupplyExceeded();\n                }\n            }\n        }\n\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "src/token/ERC20/extensions/mintable/ERC20MintableExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"../../../../common/Errors.sol\";\nimport \"../../base/ERC20BaseInternal.sol\";\nimport \"./IERC20MintableExtension.sol\";\n\n/**\n * @title Extension of {ERC20} that allows other facets of the diamond to mint based on arbitrary logic.\n */\nabstract contract ERC20MintableExtension is IERC20MintableExtension, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20MintableExtension\n     */\n    function mintByFacet(address to, uint256 amount) public virtual {\n        if (address(this) != msg.sender) {\n            revert ErrSenderIsNotSelf();\n        }\n\n        _mint(to, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20MintableExtension\n     */\n    function mintByFacet(address[] calldata tos, uint256[] calldata amounts) public virtual override {\n        if (address(this) != msg.sender) {\n            revert ErrSenderIsNotSelf();\n        }\n\n        for (uint256 i = 0; i < tos.length; i++) {\n            _mint(tos[i], amounts[i]);\n        }\n    }\n}\n"
    },
    "src/token/ERC20/base/IERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport { IERC20BaseInternal } from \"./IERC20BaseInternal.sol\";\n\n/**\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20Base is IERC20BaseInternal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(address holder, address spender) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport { IERC20BaseInternal } from \"./IERC20BaseInternal.sol\";\nimport { ERC20BaseStorage } from \"./ERC20BaseStorage.sol\";\n\n/**\n * @title Base ERC20 internal functions, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is Context, IERC20BaseInternal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(address account) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function _allowance(address holder, address spender) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        require(holder != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        require(balance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        require(holder != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        require(holderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        uint256 currentAllowance = _allowance(holder, _msgSender());\n\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n\n        unchecked {\n            _approve(holder, _msgSender(), currentAllowance - amount);\n        }\n\n        _transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"v2.flair.contracts.storage.ERC20Base\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "src/token/ERC20/base/IERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20BaseInternal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/token/ERC20/extensions/supply/ERC20SupplyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary ERC20SupplyStorage {\n    struct Layout {\n        // Maximum possible supply of tokens.\n        uint256 maxSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"v2.flair.contracts.storage.ERC20Supply\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "src/token/ERC20/extensions/supply/ERC20SupplyInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport \"../../base/ERC20BaseInternal.sol\";\nimport \"./IERC20SupplyInternal.sol\";\nimport \"./ERC20SupplyStorage.sol\";\n\nabstract contract ERC20SupplyInternal is IERC20SupplyInternal {\n    using ERC20SupplyStorage for ERC20SupplyStorage.Layout;\n\n    function _maxSupply() internal view returns (uint256) {\n        return ERC20SupplyStorage.layout().maxSupply;\n    }\n}\n"
    },
    "src/token/ERC20/extensions/supply/IERC20SupplyExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * @dev Extension of {ERC20} that tracks supply and defines a max supply cap.\n */\ninterface IERC20SupplyExtension {\n    /**\n     * @dev Maximum amount of tokens possible to exist.\n     */\n    function maxSupply() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
    },
    "src/token/ERC20/extensions/supply/IERC20SupplyInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IERC20SupplyInternal {\n    error ErrMaxSupplyExceeded();\n}\n"
    },
    "src/common/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * The caller must be the current contract itself.\n */\nerror ErrSenderIsNotSelf();\n"
    },
    "src/token/ERC20/extensions/mintable/IERC20MintableExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n/**\n * @dev Extension of {ERC20} that allows other facets from the diamond to mint tokens.\n */\ninterface IERC20MintableExtension {\n    /**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must be diamond itself (other facets).\n     */\n    function mintByFacet(address to, uint256 amount) external;\n\n    function mintByFacet(address[] memory tos, uint256[] memory amounts) external;\n}\n"
    },
    "src/token/ERC20/facets/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"../../../common/metadata/IMetadata.sol\";\n\ninterface IERC20Metadata is IMetadata {\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/token/common/metadata/IMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IMetadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n}\n"
    },
    "src/token/ERC20/facets/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport { Metadata } from \"../../../common/metadata/Metadata.sol\";\nimport { IERC20Metadata } from \"./IERC20Metadata.sol\";\nimport { ERC20MetadataInternal } from \"./ERC20MetadataInternal.sol\";\n\n/**\n * @title ERC20 - Metadata\n * @notice Provides standard read methods for name, symbol and decimals metadata for an ERC20 token.\n *\n * @custom:type eip-2535-facet\n * @custom:category Tokens\n * @custom:provides-interfaces IERC20Metadata\n */\ncontract ERC20Metadata is Metadata, IERC20Metadata, ERC20MetadataInternal {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals();\n    }\n\n    function decimalsLocked() external view returns (bool) {\n        return _decimalsLocked();\n    }\n}\n"
    },
    "src/token/common/metadata/Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./IMetadata.sol\";\nimport \"./MetadataStorage.sol\";\n\n/**\n * @title Metadata\n * @notice Provides contract name and symbol.\n *\n * @custom:type eip-2535-facet\n * @custom:category Tokens\n * @custom:provides-interfaces IMetadata\n */\ncontract Metadata is IMetadata {\n    function name() external view virtual override returns (string memory) {\n        return MetadataStorage.layout().name;\n    }\n\n    function symbol() external view virtual override returns (string memory) {\n        return MetadataStorage.layout().symbol;\n    }\n\n    function nameAndSymbolLocked() external view virtual returns (bool) {\n        return MetadataStorage.layout().nameAndSymbolLocked;\n    }\n}\n"
    },
    "src/token/ERC20/facets/metadata/ERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport { ERC20MetadataStorage } from \"./ERC20MetadataStorage.sol\";\n\n/**\n * @title ERC20Metadata internal functions\n */\nabstract contract ERC20MetadataInternal {\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function _decimals() internal view virtual returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n\n    function _decimalsLocked() internal view virtual returns (bool) {\n        return ERC20MetadataStorage.layout().decimalsLocked;\n    }\n\n    function _setDecimals(uint8 decimals_) internal virtual {\n        require(!_decimalsLocked(), \"ERC20Metadata: decimals locked\");\n        ERC20MetadataStorage.layout().decimals = decimals_;\n        ERC20MetadataStorage.layout().decimalsLocked = true;\n    }\n\n    function _setDecimalsLocked(bool decimalsLocked_) internal virtual {\n        ERC20MetadataStorage.layout().decimalsLocked = decimalsLocked_;\n    }\n}\n"
    },
    "src/token/common/metadata/MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"v2.flair.contracts.storage.Metadata\");\n\n    struct Layout {\n        string name;\n        string symbol;\n        bool nameAndSymbolLocked;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/token/ERC20/facets/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        uint8 decimals;\n        bool decimalsLocked;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"v2.flair.contracts.storage.ERC20Metadata\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "src/token/ERC20/facets/metadata/ERC20MetadataOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../../../../access/ownable/OwnableInternal.sol\";\n\nimport \"./ERC20MetadataInternal.sol\";\nimport \"./ERC20MetadataStorage.sol\";\nimport \"./IERC20MetadataAdmin.sol\";\n\n/**\n * @title ERC20 - Metadata - Admin - Ownable\n * @notice Allows diamond owner to change decimals config or freeze it forever.\n *\n * @custom:type eip-2535-facet\n * @custom:category Tokens\n * @custom:peer-dependencies IERC20Metadata\n * @custom:provides-interfaces IERC20MetadataAdmin\n */\ncontract ERC20MetadataOwnable is IERC20MetadataAdmin, ERC20MetadataInternal, OwnableInternal {\n    function setDecimals(uint8 newDecimals) external override onlyOwner {\n        ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\n        require(!l.decimalsLocked, \"ERC20MetadataOwnable: decimals locked\");\n        l.decimals = newDecimals;\n    }\n\n    function lockDecimals() external override onlyOwner {\n        ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\n        l.decimalsLocked = true;\n    }\n}\n"
    },
    "src/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./OwnableStorage.sol\";\nimport \"./IERC173Events.sol\";\n\nabstract contract OwnableInternal is IERC173Events, Context {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(_msgSender() == _owner(), \"Ownable: sender must be owner\");\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(_msgSender(), account);\n    }\n}\n"
    },
    "src/token/ERC20/facets/metadata/IERC20MetadataAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\ninterface IERC20MetadataAdmin {\n    function setDecimals(uint8 newDecimals) external;\n\n    function lockDecimals() external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1337
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}