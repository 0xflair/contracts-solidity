{
  "address": "0x883A5b91f21e3529d3A9B31D955b37Cd7382D3e2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "facetAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "facetAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facetAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "facetAddresses_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_facet",
          "type": "address"
        }
      ],
      "name": "facetFunctionSelectors",
      "outputs": [
        {
          "internalType": "bytes4[]",
          "name": "facetFunctionSelectors_",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facets",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondLoupe.Facet[]",
          "name": "facets_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9724941500b938d5b5562f0b68a13d56745432a1808b0e03f0d893662a38a829",
  "receipt": {
    "to": null,
    "from": "0xB68d649F181bDE8A8FeE367535a606Cc3C09fCCd",
    "contractAddress": "0x883A5b91f21e3529d3A9B31D955b37Cd7382D3e2",
    "transactionIndex": 4,
    "gasUsed": "380675",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x133939aae03ce3066b112ad39b8c05bc50760bedeadffc8d69e57cf6861c6e97",
    "transactionHash": "0x9724941500b938d5b5562f0b68a13d56745432a1808b0e03f0d893662a38a829",
    "logs": [],
    "blockNumber": 11362530,
    "cumulativeGasUsed": "954880",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "ffc6e07a79fa964cefe1c357bb110a4e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"facetFunctionSelectors_\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"facetAddress(bytes4)\":{\"details\":\"If facet is not found return address(0).\",\"params\":{\"_functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"facetAddresses_\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"_facet\":\"The facet address.\"},\"returns\":{\"facetFunctionSelectors_\":\"facetFunctionSelectors_\"}},\"facets()\":{\"returns\":{\"facets_\":\"Facet\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet that supports the given selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by a diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors provided by a facet.\"},\"facets()\":{\"notice\":\"Gets all facets and their selectors.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/features/diamond/DiamondLoupe.sol\":\"DiamondLoupe\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":20},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/core/DiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {IDiamondCut} from \\\"../features/diamond/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror DiamondFacetAlreadyExists(address facet, bytes4 selector);\\nerror DiamondFacetSameFunction(address facet, bytes4 selector);\\n\\nlibrary DiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct Layout {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            l.slot := position\\n        }\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        // require(\\n        //     _functionSelectors.length > 0,\\n        //     \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        // );\\n        Layout storage l = layout();\\n        // require(\\n        //     _facetAddress != address(0),\\n        //     \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        // );\\n        uint96 selectorPosition = uint96(\\n            l.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(l, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = l\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n\\n            if (oldFacetAddress != address(0)) {\\n                revert DiamondFacetAlreadyExists(oldFacetAddress, selector);\\n            }\\n\\n            addFunction(l, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        // require(\\n        //     _functionSelectors.length > 0,\\n        //     \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        // );\\n        Layout storage l = layout();\\n        // require(\\n        //     _facetAddress != address(0),\\n        //     \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        // );\\n        uint96 selectorPosition = uint96(\\n            l.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(l, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = l\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n\\n            if (oldFacetAddress == _facetAddress) {\\n                revert DiamondFacetSameFunction(oldFacetAddress, selector);\\n            }\\n\\n            removeFunction(l, oldFacetAddress, selector);\\n            addFunction(l, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        // require(\\n        //     _functionSelectors.length > 0,\\n        //     \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        // );\\n        Layout storage l = layout();\\n        // if function does not exist then do nothing and return\\n        // require(\\n        //     _facetAddress == address(0),\\n        //     \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        // );\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = l\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(l, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(Layout storage l, address _facetAddress) internal {\\n        enforceHasContractCode(\\n            _facetAddress,\\n            \\\"LibDiamondCut: New facet has no code\\\"\\n        );\\n        l.facetFunctionSelectors[_facetAddress].facetAddressPosition = l\\n            .facetAddresses\\n            .length;\\n        l.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        Layout storage l,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        l\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition = _selectorPosition;\\n        l.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n            _selector\\n        );\\n        l.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        Layout storage l,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        // require(\\n        //     _facetAddress != address(0),\\n        //     \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        // );\\n        // an immutable function is a function defined directly in a diamond\\n        // require(\\n        //     _facetAddress != address(this),\\n        //     \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        // );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = l\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = l\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = l\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            l.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                    selectorPosition\\n                ] = lastSelector;\\n            l\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        l.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete l.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = l.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = l\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = l.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                l.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                l\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = facetAddressPosition;\\n            }\\n            l.facetAddresses.pop();\\n            delete l.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata)\\n        internal\\n    {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(\\n                    _init,\\n                    \\\"LibDiamondCut: _init address has no code\\\"\\n                );\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x3b1da314ca1ef3b4e00e924d30379b9e565431d1d7a777ac41cc226977bce2a4\",\"license\":\"MIT\"},\"contracts/features/diamond/DiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {DiamondStorage} from \\\"../../core/DiamondStorage.sol\\\";\\nimport {IDiamondLoupe} from \\\"./IDiamondLoupe.sol\\\";\\n\\n// The functions in DiamondLoupe MUST be added to a diamond.\\n// The EIP-2535 Diamond standard requires these functions.\\n\\ncontract DiamondLoupe is IDiamondLoupe {\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external view override returns (Facet[] memory facets_) {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        uint256 numFacets = l.facetAddresses.length;\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; i++) {\\n            address facetAddress_ = l.facetAddresses[i];\\n            facets_[i].facetAddress = facetAddress_;\\n            facets_[i].functionSelectors = l\\n                .facetFunctionSelectors[facetAddress_]\\n                .functionSelectors;\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors provided by a facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        override\\n        returns (bytes4[] memory facetFunctionSelectors_)\\n    {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        facetFunctionSelectors_ = l\\n            .facetFunctionSelectors[_facet]\\n            .functionSelectors;\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        override\\n        returns (address[] memory facetAddresses_)\\n    {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        facetAddresses_ = l.facetAddresses;\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        override\\n        returns (address facetAddress_)\\n    {\\n        DiamondStorage.Layout storage l = DiamondStorage.layout();\\n        facetAddress_ = l\\n            .selectorToFacetAndPosition[_functionSelector]\\n            .facetAddress;\\n    }\\n}\\n\",\"keccak256\":\"0xf93a637ab907a15989ee7c5720545698de4a4829b5fd327ee5ef50ab38a62259\",\"license\":\"MIT\"},\"contracts/features/diamond/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xb85e6227a1c576c2ecca3d896f95b298ec7a918b74700d6e4999a1cd8fc89b95\",\"license\":\"MIT\"},\"contracts/features/diamond/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x58bc79a9f2484a2216b1d08185344725f0c6fbf627861fd043b36eb9c7b795b3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506105ed806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc6146100a4575b600080fd5b6100596100cf565b60405161006691906103e8565b60405180910390f35b61007761013b565b604051610066919061047a565b6100976100923660046104f7565b6102e5565b6040516100669190610527565b6100b76100b236600461053a565b61038f565b6040516001600160a01b039091168152602001610066565b606060006100db6103c4565b6002810180546040805160208084028201810190925282815293945083018282801561013057602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610112575b505050505091505090565b606060006101476103c4565b60028101549091508067ffffffffffffffff81111561016857610168610564565b6040519080825280602002602001820160405280156101ae57816020015b6040805180820190915260008152606060208201528152602001906001900390816101865790505b50925060005b818110156102df5760008360020182815481106101d3576101d361057a565b9060005260206000200160009054906101000a90046001600160a01b03169050808583815181106102065761020661057a565b6020908102919091018101516001600160a01b0392831690529082166000908152600186018252604090819020805482518185028101850190935280835291929091908301828280156102a557602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116102675790505b50505050508583815181106102bc576102bc61057a565b6020026020010151602001819052505080806102d790610590565b9150506101b4565b50505090565b606060006102f16103c4565b6001600160a01b0384166000908152600182016020908152604091829020805483518184028101840190945280845293945091929083018282801561038257602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116103445790505b5050505050915050919050565b60008061039a6103c4565b6001600160e01b03199093166000908152602093909352505060409020546001600160a01b031690565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b6020808252825182820181905260009190848201906040850190845b818110156104295783516001600160a01b031683529284019291840191600101610404565b50909695505050505050565b600081518084526020808501945080840160005b8381101561046f5781516001600160e01b03191687529582019590820190600101610449565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b838110156104e957888303603f19018552815180516001600160a01b031684528701518784018790526104d687850182610435565b95880195935050908601906001016104a1565b509098975050505050505050565b60006020828403121561050957600080fd5b81356001600160a01b038116811461052057600080fd5b9392505050565b6020815260006105206020830184610435565b60006020828403121561054c57600080fd5b81356001600160e01b03198116811461052057600080fd5b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000600182016105b057634e487b7160e01b600052601160045260246000fd5b506001019056fea264697066735822122026039a414683f1a5b2f730e6ed0f54aec2ca24971378eed5acd4ab2d30462eaa64736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc6146100a4575b600080fd5b6100596100cf565b60405161006691906103e8565b60405180910390f35b61007761013b565b604051610066919061047a565b6100976100923660046104f7565b6102e5565b6040516100669190610527565b6100b76100b236600461053a565b61038f565b6040516001600160a01b039091168152602001610066565b606060006100db6103c4565b6002810180546040805160208084028201810190925282815293945083018282801561013057602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610112575b505050505091505090565b606060006101476103c4565b60028101549091508067ffffffffffffffff81111561016857610168610564565b6040519080825280602002602001820160405280156101ae57816020015b6040805180820190915260008152606060208201528152602001906001900390816101865790505b50925060005b818110156102df5760008360020182815481106101d3576101d361057a565b9060005260206000200160009054906101000a90046001600160a01b03169050808583815181106102065761020661057a565b6020908102919091018101516001600160a01b0392831690529082166000908152600186018252604090819020805482518185028101850190935280835291929091908301828280156102a557602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116102675790505b50505050508583815181106102bc576102bc61057a565b6020026020010151602001819052505080806102d790610590565b9150506101b4565b50505090565b606060006102f16103c4565b6001600160a01b0384166000908152600182016020908152604091829020805483518184028101840190945280845293945091929083018282801561038257602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116103445790505b5050505050915050919050565b60008061039a6103c4565b6001600160e01b03199093166000908152602093909352505060409020546001600160a01b031690565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b6020808252825182820181905260009190848201906040850190845b818110156104295783516001600160a01b031683529284019291840191600101610404565b50909695505050505050565b600081518084526020808501945080840160005b8381101561046f5781516001600160e01b03191687529582019590820190600101610449565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b838110156104e957888303603f19018552815180516001600160a01b031684528701518784018790526104d687850182610435565b95880195935050908601906001016104a1565b509098975050505050505050565b60006020828403121561050957600080fd5b81356001600160a01b038116811461052057600080fd5b9392505050565b6020815260006105206020830184610435565b60006020828403121561054c57600080fd5b81356001600160e01b03198116811461052057600080fd5b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b6000600182016105b057634e487b7160e01b600052601160045260246000fd5b506001019056fea264697066735822122026039a414683f1a5b2f730e6ed0f54aec2ca24971378eed5acd4ab2d30462eaa64736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "facetAddress(bytes4)": {
        "details": "If facet is not found return address(0).",
        "params": {
          "_functionSelector": "The function selector."
        },
        "returns": {
          "facetAddress_": "The facet address."
        }
      },
      "facetAddresses()": {
        "returns": {
          "facetAddresses_": "facetAddresses_"
        }
      },
      "facetFunctionSelectors(address)": {
        "params": {
          "_facet": "The facet address."
        },
        "returns": {
          "facetFunctionSelectors_": "facetFunctionSelectors_"
        }
      },
      "facets()": {
        "returns": {
          "facets_": "Facet"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "facetAddress(bytes4)": {
        "notice": "Gets the facet that supports the given selector."
      },
      "facetAddresses()": {
        "notice": "Get all the facet addresses used by a diamond."
      },
      "facetFunctionSelectors(address)": {
        "notice": "Gets all the function selectors provided by a facet."
      },
      "facets()": {
        "notice": "Gets all facets and their selectors."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}